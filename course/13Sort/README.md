## 排序

### 一、冒泡排序

#### 算法

1. 比较相邻元素：从列表的第一个元素开始，比较相邻的两个元素。
2. 交换位置：如果前一个元素比后一个元素大，则交换它们的位置。
3. 重复遍历：对列表中的每一对相邻元素重复上述步骤，直到列表的末尾。这样，最大的元素会被"冒泡"到列表的最后。
4. 缩小范围：忽略已经排序好的最后一个元素，重复上述步骤，直到整个列表排序完成。

#### 演示

![](bubbleSort.gif)

#### 例子

假设有一个待排序的列表 [5, 3, 8, 4, 6]，冒泡排序的过程如下：

* 第一轮遍历：
  * 比较 5 和 3，交换位置，列表变为 [3, 5, 8, 4, 6]。
  * 比较 5 和 8，不交换。 
  * 比较 8 和 4，交换位置，列表变为 [3, 5, 4, 8, 6]。 
  * 比较 8 和 6，交换位置，列表变为 [3, 5, 4, 6, 8]。 
  * 第一轮结束后，最大的元素 8 已经"冒泡"到列表的最后。

* 第二轮遍历： 
  * swapped = False 还没交换过
  * 比较 3 和 5，不交换。 
  * 比较 5 和 4，交换位置，swapped = True，列表变为 [3, 4, 5, 6, 8]。 
  * 比较 5 和 6，不交换。 
  * 第二轮结束后，第二大的元素 6 已经"冒泡"到列表的倒数第二位置。

* 第三轮遍历： 
  * swapped = False 还没交换过
  * 比较 3 和 4，不交换。 
  * 比较 4 和 5，不交换。
  * [3, 4, 5, 6, 8]
  * 第三轮结束后，列表已经有序。

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # 标记是否发生了交换
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                # 交换位置
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        # 如果没有发生交换，说明列表已经有序，提前退出
        if not swapped:
            break
    return arr

# 示例
arr = [5, 3, 8, 4, 6]
sorted_arr = bubble_sort(arr)
print(sorted_arr)  # 输出: [3, 4, 5, 6, 8]
```

### 二、选择排序

#### 算法

1. 初始化：将列表分为已排序部分和未排序部分。初始时，已排序部分为空，未排序部分为整个列表。
2. 查找最小值：在未排序部分中查找最小的元素。
3. 交换位置：将找到的最小元素与未排序部分的第一个元素交换位置。
4. 更新范围：将未排序部分的起始位置向后移动一位，扩大已排序部分的范围。
5. 重复步骤：重复上述步骤，直到未排序部分为空，列表完全有序。

#### 演示

![](selectionSort.gif)

#### 例子

假设有一个待排序的列表 [64, 25, 12, 22, 11]，选择排序的过程如下：

* 第一轮遍历： 
  * 未排序部分：[64, 25, 12, 22, 11]。 
  * 找到最小值 11，将其与第一个元素 64 交换。 
  * 列表变为 [11, 25, 12, 22, 64]。 
  * 已排序部分：[11]，未排序部分：[25, 12, 22, 64]。

* 第二轮遍历： 
  * 未排序部分：[25, 12, 22, 64]。 
  * 找到最小值 12，将其与第一个元素 25 交换。 
  * 列表变为 [11, 12, 25, 22, 64]。 
  * 已排序部分：[11, 12]，未排序部分：[25, 22, 64]。

* 第三轮遍历： 
  * 未排序部分：[25, 22, 64]。 
  * 找到最小值 22，将其与第一个元素 25 交换。 
  * 列表变为 [11, 12, 22, 25, 64]。 
  * 已排序部分：[11, 12, 22]，未排序部分：[25, 64]。

* 第四轮遍历： 
  * 未排序部分：[25, 64]。 
  * 找到最小值 25，它已经在正确的位置，无需交换。 
  * 列表保持不变：[11, 12, 22, 25, 64]。 
  * 已排序部分：[11, 12, 22, 25]，未排序部分：[64]。

* 第五轮遍历： 
  * 未排序部分：[64]。 
  * 只有一个元素，无需操作。 
  * 列表完全有序：[11, 12, 22, 25, 64]。

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        # 假设当前未排序部分的第一个元素是最小值
        min_idx = i
        # 在未排序部分中查找最小值的索引
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        # 将最小值与未排序部分的第一个元素交换
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# 示例
arr = [64, 25, 12, 22, 11]
sorted_arr = selection_sort(arr)
print(sorted_arr)  # 输出: [11, 12, 22, 25, 64]
```